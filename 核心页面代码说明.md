# 第3章 核心页面代码实现

## 3.1 首页代码实现 (Home.vue)

**文件位置：** `src/views/Home.vue`

### 3.1.1 页面结构代码

首页的HTML结构主要分为几个部分：公告栏、轮播图区域、文章列表和侧边栏。

**公告栏代码：**

📍 **截图位置：** `src/views/Home.vue` 第15-22行（`<template>`部分）

```vue
<el-alert
  title="最新消息"
  type="info"
  :closable="false"
  class="announcement"
>
  Hailin正在制作超级好玩的大型3D游戏...
</el-alert>
```

这部分比较简单，直接用的Element Plus的Alert组件。`:closable="false"`表示不显示关闭按钮，这个是参考官方文档写的。

**轮播图代码：**

📍 **截图位置：** `src/views/Home.vue` 第30-40行（`<template>`部分）

```vue
<n-carousel autoplay :interval="4000" show-arrow>
  <img
    v-for="(banner, index) in carouselImages"
    :key="index"
    class="carousel-img"
    :src="banner.src"
    :alt="banner.alt"
  />
</n-carousel>
```

这里用的是Naive UI的轮播图组件。`autoplay`表示自动播放，`:interval="4000"`表示每4秒切换一次。`v-for`循环渲染图片，这个是课堂学的Vue基础语法。

**文章列表代码：**

📍 **截图位置：** `src/views/Home.vue` 第70-90行（`<template>`部分）

```vue
<el-row :gutter="20" class="articles-grid">
  <el-col
    v-for="article in articles"
    :key="article.id"
    :xs="12"
    :sm="12"
    :md="12"
  >
    <el-card class="article-card" shadow="hover" @click="goToArticle(article.id)">
      <!-- 文章内容 -->
    </el-card>
  </el-col>
</el-row>
```

这里用Element Plus的栅格系统做响应式布局。`:xs="12"`表示在超小屏幕上占12格（一半），`:md="12"`表示在中等屏幕上也占12格。这样就实现了两列布局。栅格系统的用法参考了Element Plus官方文档。

### 3.1.2 数据定义代码

**轮播图数据：**

📍 **截图位置：** `src/views/Home.vue` 第140-155行（`<script setup>`部分）

```javascript
const carouselImages = ref([
  {
    src: 'https://tc.hailin.ip-ddns.com/file/blog/1761987131084_html5.png',
    alt: '轮播图1'
  },
  // 更多图片...
])
```

这个比较简单，就是定义一个数组，存放图片的路径和描述。`ref()`是Vue 3的响应式API，课堂学的。

**文章数据：**

📍 **截图位置：** `src/views/Home.vue` 第165-195行（`<script setup>`部分）

```javascript
const articles = ref([
  {
    id: 1,
    title: '计算机是如何工作的',
    badge1: '大学生涯',
    badge2: '最新',
    tags: ['教程', 'JAVAEE'],
    date: '2025-9-17',
    image: 'https://...'
  },
  // 更多文章...
])
```

文章数据的结构是我自己设计的，包括标题、标签、日期、图片等信息。

### 3.1.3 交互逻辑代码

**文章跳转函数：**

📍 **截图位置：** `src/views/Home.vue` 第200-203行（`<script setup>`部分）

```javascript
const goToArticle = (id) => {
  router.push(`/article/${id}`)
}
```

这个函数用来跳转到文章详情页。`router.push()`是Vue Router的API，参考了官方文档。用模板字符串`` `${id}` ``拼接路由参数，这个是ES6语法，课堂学的。

**标签筛选逻辑：**
```javascript
const activeTag = ref('全部')
const tags = ['全部', '前端开发', '大学生活', '更多']
```

这部分定义了标签数据和当前激活的标签。点击标签时会改变`activeTag`的值，然后根据这个值筛选文章。筛选逻辑比较简单，就是用`v-if`判断，这个是我自己写的。

### 3.1.4 样式代码

**文章卡片悬停效果：**
```css
.article-card:hover .article-image {
  transform: scale(1.1);
}
```

这个是CSS3的变换效果，鼠标悬停时图片放大1.1倍。`transform: scale()`是课堂学的。

**个人信息卡片渐变背景：**
```css
.profile-card {
  background: linear-gradient(135deg, #445cf0 0%, #4c63f0 100%);
  border-radius: 25px;
  box-shadow: 0 8px 30px rgba(102, 126, 234, 0.3);
}
```

这个渐变背景的样式是从UIverse.io找的，我调整了颜色值。`linear-gradient()`是CSS3的渐变函数，参考了网上教程。

**翻转卡片效果：**
```css
.flip-card:hover .flip-card-inner {
  transform: rotateY(180deg);
}
```

这个3D翻转效果也是从UIverse.io找的。`rotateY(180deg)`表示沿Y轴旋转180度，实现翻转效果。

---

## 3.2 视频列表页代码实现 (Videos.vue)

**文件位置：** `src/views/Videos.vue`

### 3.2.1 视频播放器代码

**HTML5 Video标签：**

📍 **截图位置：** `src/views/Videos.vue` 第20-30行（`<template>`部分）

```vue
<video 
  :id="'video-' + video.id"
  :ref="el => videoRefs[video.id] = el"
  class="video-player"
  width="850"
  height="400"
  :src="video.src"
>
  您的浏览器不支持video标签
</video>
```

这里用的是HTML5原生的`<video>`标签，这个是课堂学的。`:ref`是Vue 3的新语法，用来获取DOM元素的引用，这个语法比较复杂，用了AI帮忙理解。

**为什么用AI：** Vue 3的ref语法和Vue 2不一样，特别是在`v-for`循环中使用ref，需要用函数的形式，这个比较难理解，所以用AI帮忙解释和生成代码。

### 3.2.2 视频控制逻辑

**播放/暂停函数：**

📍 **截图位置：** `src/views/Videos.vue` 第120-132行（`<script setup>`部分）

```javascript
const togglePlay = (videoId) => {
  const video = videoRefs[videoId]
  if (!video) return

  if (video.paused) {
    video.play()
    playingStates[videoId] = true
  } else {
    video.pause()
    playingStates[videoId] = false
  }
}
```

这个函数用来控制视频的播放和暂停。`video.paused`、`video.play()`、`video.pause()`都是HTML5 Video API，课堂学的，也参考了MDN文档。`playingStates`是我自己定义的一个对象，用来记录每个视频的播放状态。

**快进/快退函数：**
```javascript
const goBack = (videoId, val) => {
  const video = videoRefs[videoId]
  if (!video) return
  video.currentTime += val
}
```

这个函数通过改变`video.currentTime`来实现快进快退。`currentTime`是Video API的属性，表示当前播放时间（秒）。这个是课堂学的。

**播放速度控制：**
```javascript
const setSpeed = (videoId, speed) => {
  const video = videoRefs[videoId]
  if (!video) return
  video.playbackRate = speed
}
```

`playbackRate`是Video API的属性，用来控制播放速度。1表示正常速度，1.5表示1.5倍速，2表示2倍速。这个是参考MDN文档写的。

**时间显示函数：**

📍 **截图位置：** `src/views/Videos.vue` 第180-187行（`<script setup>`部分）

```javascript
const formatTime = (second) => {
  const fen = Math.floor(second / 60)
  const fenStr = fen >= 10 ? fen : '0' + fen
  const miao = Math.floor(second % 60)
  const miaoStr = miao >= 10 ? miao : '0' + miao
  return fenStr + ':' + miaoStr
}
```

这个函数把秒数转换成"分:秒"的格式。涉及到数学计算（除法、取余）和字符串处理（补零），比较复杂，用了AI帮忙写。

**为什么用AI：** 时间格式化涉及到数学运算和条件判断，特别是补零的逻辑（小于10要在前面加0），自己写容易出错，所以用AI生成。

**时间更新监听：**
```javascript
onMounted(() => {
  videos.value.forEach(video => {
    const videoElement = videoRefs[video.id]
    if (videoElement) {
      videoElement.ontimeupdate = () => {
        updateTimeDisplay(video.id)
      }
    }
  })
})
```

这段代码在页面加载时给每个视频添加时间更新监听。`ontimeupdate`是Video API的事件，每次播放时间改变时触发。这个监听逻辑用了AI帮忙写，因为涉及到循环遍历和事件绑定。

**为什么用AI：** 需要给多个视频同时添加监听，涉及到数组遍历、DOM操作、事件绑定，逻辑比较复杂，用AI生成更可靠。

### 3.2.3 音频播放器代码

**HTML5 Audio标签：**
```vue
<audio 
  ref="globalAudioPlayer"
  @play="onAudioPlay"
  @pause="onAudioPause"
  @ended="onAudioEnded"
></audio>
```

这里用的是HTML5的`<audio>`标签，课堂学的。`@play`、`@pause`、`@ended`是Vue的事件监听语法，分别监听播放、暂停、播放结束事件。

**进度条控制：**
```javascript
const seekAudio = (e) => {
  if (!musicPlayer.value) return
  
  const rect = e.currentTarget.getBoundingClientRect()
  const percent = (e.clientX - rect.left) / rect.width
  musicPlayer.value.currentTime = percent * musicPlayer.value.duration
}
```

这个函数实现点击进度条跳转到指定位置。`getBoundingClientRect()`获取元素位置，`e.clientX`获取点击位置，然后计算百分比。这个逻辑比较复杂，用了AI帮忙写。

**为什么用AI：** 进度条的点击跳转涉及到坐标计算、百分比转换、时间设置，需要理解DOM的坐标系统，比较难，所以用AI生成。

**进度更新显示：**
```javascript
const updateProgress = () => {
  if (!musicPlayer.value) return
  
  const { currentTime: ct, duration: dur } = musicPlayer.value
  progressPercent.value = (ct / dur) * 100
  currentTime.value = formatTime(ct)
}
```

这个函数实时更新进度条和时间显示。用了ES6的解构赋值语法，这个是课堂学的。进度百分比的计算比较简单，是我自己写的。

---

## 3.3 联系页代码实现 (Contact.vue)

**文件位置：** `src/views/Contact.vue`

### 3.3.1 表单结构代码

**表单组件：**

📍 **截图位置：** `src/views/Contact.vue` 第35-45行（`<template>`部分）

```vue
<el-form
  ref="formRef"
  :model="form"
  :rules="rules"
  label-width="80px"
  label-position="top"
>
  <!-- 表单项 -->
</el-form>
```

这里用的是Element Plus的表单组件。`:model="form"`绑定表单数据，`:rules="rules"`绑定验证规则。这个是参考Element Plus官方文档写的。

**表单字段：**
```vue
<el-form-item label="姓名" prop="name">
  <el-input v-model="form.name" placeholder="请输入您的姓名" />
</el-form-item>
```

`prop="name"`指定验证规则对应的字段，`v-model`实现双向数据绑定。这些都是Vue的基础语法，课堂学的。

### 3.3.2 表单数据定义

**表单数据对象：**
```javascript
const form = reactive({
  name: '',
  email: '',
  phone: '',
  subject: '',
  message: ''
})
```

用`reactive()`定义响应式对象，这个是Vue 3的API，课堂学的。

### 3.3.3 表单验证规则

**验证规则配置：**

📍 **截图位置：** `src/views/Contact.vue` 第115-140行（`<script setup>`部分）

```javascript
const rules = {
  name: [
    { required: true, message: '请输入您的姓名', trigger: 'blur' },
    { min: 2, max: 20, message: '姓名长度在 2 到 20 个字符', trigger: 'blur' }
  ],
  email: [
    { required: true, message: '请输入您的邮箱', trigger: 'blur' },
    { type: 'email', message: '请输入有效的邮箱地址', trigger: 'blur' }
  ],
  // 更多规则...
}
```

这个验证规则配置用了AI帮忙写，因为规则比较多，而且每个字段的验证要求不一样。

**为什么用AI：** 表单验证规则涉及到多个字段、多种验证类型（必填、长度、格式），配置比较繁琐，容易漏掉或写错，用AI生成更完整可靠。

**自定义验证函数：**

📍 **截图位置：** `src/views/Contact.vue` 第105-112行（`<script setup>`部分）

```javascript
const validatePhone = (rule, value, callback) => {
  if (value && !/^1[3-9]\d{9}$/.test(value)) {
    callback(new Error('请输入有效的手机号码'))
  } else {
    callback()
  }
}
```

这个是自定义验证器，用来验证手机号格式。正则表达式`/^1[3-9]\d{9}$/`是从网上找的，表示以1开头，第二位是3-9，后面9位是数字。自定义验证器的写法用了AI帮忙，因为涉及到回调函数和错误处理。

**为什么用AI：** 自定义验证器的语法比较特殊，需要理解`callback`的用法，而且要正确处理错误信息，用AI生成更准确。

### 3.3.4 表单提交逻辑

**提交函数：**

📍 **截图位置：** `src/views/Contact.vue` 第145-165行（`<script setup>`部分）

```javascript
const submitForm = async () => {
  if (!formRef.value) return

  await formRef.value.validate((valid) => {
    if (valid) {
      loading.value = true
      
      setTimeout(() => {
        loading.value = false
        ElMessage.success('留言发送成功！我会尽快回复您。')
        formRef.value.resetFields()
      }, 1500)
    } else {
      ElMessage.error('请检查表单填写是否正确')
    }
  })
}
```

这个函数用了AI帮忙写，因为涉及到异步验证、错误处理、消息提示、表单重置等多个步骤。

**为什么用AI：** 
1. `async/await`异步语法比较复杂
2. `formRef.value.validate()`的回调函数写法需要理解
3. 需要处理验证成功和失败两种情况
4. 涉及到多个API的组合使用（ElMessage、resetFields）

这些逻辑串联起来比较复杂，自己写容易出错，用AI生成更可靠。

### 3.3.5 联系方式卡片样式

**卡片悬停效果：**
```css
.cards .card:hover {
  transform: scale(1.1, 1.1);
}

.cards:hover > .card:not(:hover) {
  filter: blur(10px);
  transform: scale(0.9, 0.9);
}
```

这个效果是从UIverse.io找的。第一个规则让悬停的卡片放大，第二个规则让其他卡片模糊缩小。`:not(:hover)`是CSS选择器，表示"不是悬停状态的元素"。

---

## 3.4 文章列表页代码实现 (Articles.vue)

### 3.4.1 文章数据渲染

**文章列表循环：**
```vue
<el-col
  v-for="article in articles"
  :key="article.id"
  :xs="24"
  :sm="12"
  :md="12"
>
  <el-card class="article-card">
    <!-- 文章内容 -->
  </el-card>
</el-col>
```

用`v-for`循环渲染文章列表，`:key`绑定唯一标识。响应式栅格配置：手机上占满（24格），平板和电脑上占一半（12格）。这些都是参考Element Plus文档写的。

### 3.4.2 分页组件

**分页代码：**
```vue
<el-pagination
  background
  class="pagination"
  layout="prev, pager, next"
  :total="50"
  :page-size="4"
/>
```

直接用的Element Plus的分页组件，`layout`指定显示哪些部分，`:total`是总条数，`:page-size`是每页条数。这个是参考官方文档写的。

---

## 3.5 关于页代码实现 (About.vue)

### 3.5.1 时间线组件

**时间线代码：**
```vue
<el-timeline>
  <el-timeline-item
    v-for="item in timeline"
    :key="item.id"
    :timestamp="item.date"
  >
    <h3>{{ item.title }}</h3>
    <p>{{ item.description }}</p>
  </el-timeline-item>
</el-timeline>
```

用的是Element Plus的时间线组件，直接参考官方文档写的。`v-for`循环渲染时间线项目，这个是Vue基础语法。

---

## 3.6 全局组件代码实现

### 3.6.1 主题切换组件 (ThemeSwitch.vue)

**文件位置：** `src/components/ThemeSwitch.vue`

**切换逻辑：**

📍 **截图位置：** `src/components/ThemeSwitch.vue` 第15-28行（`<script setup>`部分）

```javascript
const isDarkMode = ref(false)

const toggleTheme = () => {
  isDarkMode.value = !isDarkMode.value
  
  if (isDarkMode.value) {
    document.documentElement.classList.add('dark-mode')
    localStorage.setItem('theme', 'dark')
  } else {
    document.documentElement.classList.remove('dark-mode')
    localStorage.setItem('theme', 'light')
  }
}
```

这个切换逻辑用了AI帮忙写，因为涉及到：
1. DOM操作（给`<html>`标签添加/移除类）
2. 本地存储（记住用户选择）
3. 状态管理（全局变量）

**为什么用AI：** 主题切换需要操作DOM、使用localStorage、管理全局状态，这些API的组合使用比较复杂，用AI生成更可靠。

**样式代码：**

📍 **截图位置：** `src/components/ThemeSwitch.vue` 第40-80行（`<style scoped>`部分）

主题切换按钮的样式是从UIverse.io找的，包括太阳和月亮的图标、切换动画等。

### 3.6.2 全局音乐播放器

**播放器状态管理：**
```javascript
// musicStore.js
export const isMusicPlaying = ref(false)
export const currentSong = ref({})
export const songs = ref([...])
export const musicPlayer = ref(null)

export const toggleMusicPlay = () => {
  if (!musicPlayer.value) return
  
  if (musicPlayer.value.paused) {
    musicPlayer.value.play()
  } else {
    musicPlayer.value.pause()
  }
}
```

这个全局状态管理用了AI帮忙写，因为需要在多个组件之间共享音乐播放状态。

**为什么用AI：** 全局状态管理涉及到模块导出、响应式数据共享、多组件通信，比较复杂，用AI生成更规范。

**悬浮按钮样式：**

悬浮音乐播放按钮的样式是从UIverse.io找的，包括三个渐变色按钮、悬停展开效果、音符动画等。

### 3.6.3 星空背景组件 (StarryBackground.vue)

**文件位置：** `src/components/StarryBackground.vue`

**Canvas绘制代码：**

📍 **截图位置：** `src/components/StarryBackground.vue` 第15-60行（`<script setup>`部分）

```javascript
const canvas = ref(null)
let ctx = null
let stars = []

const initCanvas = () => {
  ctx = canvas.value.getContext('2d')
  canvas.value.width = window.innerWidth
  canvas.value.height = window.innerHeight
  
  // 创建星星
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: Math.random() * canvas.value.width,
      y: Math.random() * canvas.value.height,
      radius: Math.random() * 2,
      speed: Math.random() * 0.5
    })
  }
  
  animate()
}

const animate = () => {
  ctx.clearRect(0, 0, canvas.value.width, canvas.value.height)
  
  stars.forEach(star => {
    ctx.beginPath()
    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2)
    ctx.fillStyle = 'white'
    ctx.fill()
    
    star.y += star.speed
    if (star.y > canvas.value.height) {
      star.y = 0
    }
  })
  
  requestAnimationFrame(animate)
}
```

这个Canvas动画效果用了AI帮忙写，因为涉及到：
1. Canvas API的使用
2. 动画循环（requestAnimationFrame）
3. 数学计算（随机数、圆的绘制）
4. 性能优化

**为什么用AI：** Canvas动画涉及到图形绘制、动画循环、性能优化等多个方面，代码量大，逻辑复杂，用AI生成更高效。

---

## 3.7 代码开发总结

### 3.7.1 自己编写的代码

- 简单的数据定义（文章数据、轮播图数据等）
- 基础的Vue语法（v-for、v-if、v-model等）
- 简单的函数（路由跳转、标签切换等）
- 基础的CSS样式（颜色、字体、间距等）

### 3.7.2 参考文档编写的代码

- Element Plus组件的使用（参考官方文档）
- Vue 3 API的使用（参考官方文档）
- HTML5 Video/Audio API（参考MDN文档）
- CSS3基础样式（参考课堂教学）

### 3.7.3 AI辅助编写的代码

**为什么用AI：**
1. **复杂的逻辑处理** - 涉及多个步骤、多个API的组合
2. **不熟悉的语法** - Vue 3新语法、高级特性
3. **容易出错的代码** - 异步处理、事件监听、状态管理
4. **重复性工作** - 表单验证规则、多个相似函数

**AI辅助的具体部分：**
- 响应式菜单切换逻辑
- 文章数据渲染逻辑
- 视频ref获取和事件监听
- 时间格式化函数
- 音频进度条交互逻辑
- 表单验证规则配置
- 自定义验证函数
- 表单提交函数
- 主题切换逻辑
- 全局音乐播放器状态管理
- Canvas星空动画效果

### 3.7.4 从UIverse.io引用的样式

- 主题切换按钮样式
- 个人信息卡片渐变背景
- 翻转卡片3D效果
- 文章详情页卡片悬停效果
- 联系方式卡片悬停效果
- 全局音乐播放器按钮样式

---

**说明：** 本文档详细说明了每个核心页面的代码实现，包括HTML结构、JavaScript逻辑、CSS样式，并如实标注了AI辅助编写的部分和原因。
